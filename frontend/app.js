/**
 * Trondheim Historical Map Application
 *
 * This application displays a historical map of Trondheim with temporal filtering.
 * Features are filtered based on their start_date and end_date attributes.
 */

// Configuration
const CONFIG = {
    // Map center on Trondheim, Norway
    center: [10.39, 63.43],
    zoom: 12,
    minZoom: 8,
    maxZoom: 18,

    // PMTiles source paths (relative to server root in frontend/)
    pmtilesPath: 'data/trondheim.pmtiles',  // OSM base (roads, water, landuse)
    buildingsPath: 'data/buildings_temporal.pmtiles',  // Buildings with SEFRAK dates

    // Default year
    defaultYear: 2020,

    // Year range
    minYear: 1700,  // Extended to show oldest SEFRAK buildings
    maxYear: 2025,

    // Historical era threshold (pre-1950 features get historical styling)
    historicalThreshold: 1950,

    // Key historical dates for slider markers
    keyDates: [1700, 1800, 1850, 1900, 1950, 2000, 2025]
};

// Global state
let map = null;
let currentYear = CONFIG.defaultYear;
let animationFrameId = null;
let isAnimating = false;
let layerVisibility = {
    buildings: true,
    roads: true,
    roadsHistorical: true,  // ML-detected historical roads
    water: true,
    confidenceOverlay: false
};

// Cache for GeoJSON data to enable accurate counting
let buildingsDataCache = null;
let roadsDataCache = null;

// Type A: Date Sources (timeline-aware) - buildings with construction dates
let dateSourceFilter = {
    man: true,    // Manual (researcher verified)
    sef: true,    // SEFRAK
    tk: true,     // Trondheim Kommune
    mat: true,    // Matrikkelen
    finn: true,   // Finn.no (property listings with construction dates)
    osm: true     // OpenStreetMap
};

// Type B: Historical Snapshots (static) - ML-detected from historical maps
// These show all buildings from that era, regardless of timeline
let snapshotFilter = {
    kv1880: true,   // Kartverket 1880
    kv1904: false,  // Kartverket 1904 (off by default)
    air1947: false  // Aerial 1947 (off by default)
};

// Legacy aliases for backwards compatibility (deprecated)
let sourceFilter = dateSourceFilter;
let mlSourceFilter = snapshotFilter;

// Source filter toggle (debug mode)
// OFF (default/production): Year slider controls visibility, all sources shown
// ON (debug): Additional source filtering - can show/hide individual sources
let sourceFilterEnabled = false;

// Debug color mode - shows date sources and inheritance methods
// OFF: Normal era-based coloring
// ON: Color by sd_src (date source) and sd_method (inheritance method)
let debugColorMode = false;

// Edit mode state
let editMode = false;
let editPopup = null;

// Road source filter
let roadSourceFilter = {
    nvdb: true,        // NVDB official road database (with construction dates)
    kult: true,        // Kulturminnesøk heritage roads
    ml_kv1880: true,   // ML from Kartverket 1880
    ml_kv1904: true,   // ML from Kartverket 1904
    ml_air1947: true,  // ML from Aerial 1947
    osm: true          // Modern OSM roads (baseline)
};

// Road type filter
let roadTypeFilter = {
    motorway: true,
    primary: true,
    secondary: true,
    tertiary: true,
    residential: true,
    path: true
};

// Road date range filter (simplified - always show all)
let roadDateRange = {
    from: 1700,
    to: 2025
};

// Base map layer visibility
let baseMapLayers = {
    water: true,
    landuse: true,
    labels: true
};

// Source inspection mode state
let inspectionMode = {
    active: false,
    source: null,      // 'kv1880', 'kv1904', 'air1947'
    featureType: 'all' // 'all', 'buildings', 'roads'
};

// Historical map sources - loaded from manifest (generated by pipeline)
// See: scripts/export/export_sources_manifest.py
let historicalMapSources = null;

/**
 * Load historical map sources from manifest
 * @returns {Promise<object>} The sources manifest
 */
async function loadSourcesManifest() {
    if (historicalMapSources) {
        return historicalMapSources;
    }

    try {
        const response = await fetch('data/sources_manifest.json');
        if (!response.ok) {
            throw new Error(`Failed to load manifest: ${response.status}`);
        }
        const manifest = await response.json();

        // Convert manifest format to internal format
        historicalMapSources = {};
        for (const [key, source] of Object.entries(manifest.sources)) {
            const converted = {
                name: source.name,
                year: source.year,
                bounds: source.bounds,
            };

            if (source.raster) {
                converted.type = source.raster.type;
                converted.attribution = source.raster.attribution || '';

                if (source.raster.type === 'tiles') {
                    converted.tiles = [source.raster.url];
                    converted.minzoom = source.raster.minzoom || 10;
                    converted.maxzoom = source.raster.maxzoom || 16;
                    if (source.raster.bounds) {
                        converted.bounds = source.raster.bounds;
                    }
                } else if (source.raster.type === 'image' || source.raster.type === 'mosaic') {
                    converted.images = source.raster.images || [];
                    // For single image, also set url for backwards compat
                    if (source.raster.type === 'image' && converted.images.length === 1) {
                        converted.url = converted.images[0].url;
                        converted.bounds = converted.images[0].bounds;
                    }
                }
            }

            // Add feature file paths
            if (source.features) {
                converted.features = source.features;
            }

            historicalMapSources[key] = converted;
        }

        console.log('Loaded historical map sources:', Object.keys(historicalMapSources));
        updateInspectionButtons();
        return historicalMapSources;
    } catch (e) {
        console.warn('Could not load sources manifest:', e);
        console.log('Inspection mode will be unavailable until manifest is generated.');
        console.log('Run: python3 scripts/export/export_sources_manifest.py');
        return null;
    }
}

/**
 * Update inspection mode buttons based on available sources
 */
function updateInspectionButtons() {
    const container = document.querySelector('#inspectionDropdown .inspection-buttons');
    if (!container || !historicalMapSources) return;

    // Clear existing buttons
    container.innerHTML = '';

    // Create button for each source
    for (const [key, source] of Object.entries(historicalMapSources)) {
        const btn = document.createElement('button');
        btn.className = 'inspection-btn';
        btn.onclick = () => enterInspectionMode(key);
        btn.innerHTML = `
            <span class="btn-year">${source.year}</span>
            <span class="btn-name">${source.name.replace(/\d+/g, '').trim()}</span>
        `;
        container.appendChild(btn);
    }
}

/**
 * Initialize the PMTiles protocol handler
 */
function initPMTiles() {
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol('pmtiles', protocol.tile);
    console.log('PMTiles protocol initialized');
}

/**
 * Get historical styling for features based on year and confidence
 * @param {number} year - The current selected year
 * @returns {object} Styling parameters for historical features
 */
function getHistoricalStyle(year) {
    const isHistorical = year < CONFIG.historicalThreshold;

    if (isHistorical) {
        return {
            // Sepia tones for buildings - more intense for older dates
            buildingColor: [
                'interpolate',
                ['linear'],
                ['coalesce', ['get', 'start_date'], year],
                1850, '#b89968',  // Dark sepia for very old
                1900, '#c9a876',  // Medium sepia
                1950, '#d4a373',  // Light sepia/tan
                2000, '#d4a373'   // Normal color for modern
            ],
            // Opacity based on confidence if available
            buildingOpacity: [
                'case',
                ['has', 'confidence'],
                ['*', ['get', 'confidence'], 0.8],
                isHistorical ? 0.75 : 0.8
            ],
            waterColor: isHistorical ? '#6b9bc3' : '#4a90e2',
            backgroundColor: isHistorical ? '#e8dfc8' : '#f0ebe0'
        };
    }

    return {
        buildingColor: '#d4a373',
        buildingOpacity: 0.8,
        waterColor: '#4a90e2',
        backgroundColor: '#f0ebe0'
    };
}

/**
 * Create the map style with temporal filtering and historical styling
 * @param {number} year - The year to filter features by
 * @returns {object} MapLibre style object
 */
function createMapStyle(year) {
    const style = getHistoricalStyle(year);

    return {
        version: 8,
        name: 'Trondheim Historical',
        glyphs: 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
        sources: {
            trondheim: {
                type: 'vector',
                url: `pmtiles://${CONFIG.pmtilesPath}`,
                attribution: '&copy; OpenStreetMap contributors'
            },
            'buildings-dated': {
                type: 'vector',
                url: `pmtiles://${CONFIG.buildingsPath}`,
                attribution: '&copy; OSM + SEFRAK + ML building dating'
            },
            'roads-temporal': {
                type: 'geojson',
                data: 'data/roads_temporal.geojson',
                attribution: '&copy; ML-detected historical roads'
            },
            'finn-buildings': {
                type: 'geojson',
                data: 'data/sources/finn/normalized/buildings.geojson',
                attribution: '&copy; Finn.no property listings'
            }
        },
        layers: [
            // Background
            {
                id: 'background',
                type: 'background',
                paint: {
                    'background-color': style.backgroundColor
                }
            },

            // Water bodies
            {
                id: 'water',
                type: 'fill',
                source: 'trondheim',
                'source-layer': 'water',
                filter: createTemporalFilter(year),
                layout: {
                    'visibility': layerVisibility.water ? 'visible' : 'none'
                },
                paint: {
                    'fill-color': style.waterColor,
                    'fill-opacity': 0.7
                }
            },
            {
                id: 'water-outline',
                type: 'line',
                source: 'trondheim',
                'source-layer': 'water',
                filter: createTemporalFilter(year),
                layout: {
                    'visibility': layerVisibility.water ? 'visible' : 'none'
                },
                paint: {
                    'line-color': style.waterColor === '#4a90e2' ? '#2e5f8a' : '#4a6b8c',
                    'line-width': 1,
                    'line-opacity': 0.6
                }
            },

            // Landuse (parks, forests, etc.)
            {
                id: 'landuse',
                type: 'fill',
                source: 'trondheim',
                'source-layer': 'landuse',
                filter: createTemporalFilter(year),
                paint: {
                    'fill-color': [
                        'match',
                        ['get', 'class'],
                        'park', '#7fb069',
                        'forest', '#5a8c4f',
                        'grass', '#8bc34a',
                        'cemetery', '#9eb384',
                        '#c8d5b9'
                    ],
                    'fill-opacity': 0.6
                }
            },

            // Roads - background (wider)
            {
                id: 'roads-background',
                type: 'line',
                source: 'trondheim',
                'source-layer': 'transportation',
                filter: ['all', createTemporalFilter(year), ['in', 'class', 'motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'minor', 'service']],
                layout: {
                    'visibility': layerVisibility.roads ? 'visible' : 'none'
                },
                paint: {
                    'line-color': '#ffffff',
                    'line-width': [
                        'interpolate',
                        ['exponential', 1.5],
                        ['zoom'],
                        10, [
                            'match',
                            ['get', 'class'],
                            'motorway', 3,
                            'trunk', 2.5,
                            'primary', 2,
                            'secondary', 1.5,
                            'tertiary', 1,
                            'minor', 0.5,
                            'service', 0.3,
                            0.5
                        ],
                        14, [
                            'match',
                            ['get', 'class'],
                            'motorway', 8,
                            'trunk', 6,
                            'primary', 5,
                            'secondary', 4,
                            'tertiary', 3,
                            'minor', 2,
                            'service', 1.5,
                            1
                        ]
                    ],
                    'line-opacity': 0.8
                }
            },

            // Roads - foreground
            {
                id: 'roads',
                type: 'line',
                source: 'trondheim',
                'source-layer': 'transportation',
                filter: ['all', createTemporalFilter(year), ['in', 'class', 'motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'minor', 'service']],
                layout: {
                    'visibility': layerVisibility.roads ? 'visible' : 'none'
                },
                paint: {
                    'line-color': [
                        'match',
                        ['get', 'class'],
                        'motorway', '#e67e22',
                        'trunk', '#d68910',
                        'primary', '#888888',
                        'secondary', '#999999',
                        'tertiary', '#aaaaaa',
                        '#bbbbbb'
                    ],
                    'line-width': [
                        'interpolate',
                        ['exponential', 1.5],
                        ['zoom'],
                        10, [
                            'match',
                            ['get', 'class'],
                            'motorway', 2,
                            'trunk', 1.5,
                            'primary', 1.2,
                            'secondary', 1,
                            'tertiary', 0.7,
                            'minor', 0.4,
                            'service', 0.2,
                            0.3
                        ],
                        14, [
                            'match',
                            ['get', 'class'],
                            'motorway', 6,
                            'trunk', 4.5,
                            'primary', 3.5,
                            'secondary', 3,
                            'tertiary', 2,
                            'minor', 1.5,
                            'service', 1,
                            0.5
                        ]
                    ],
                    'line-opacity': 1
                }
            },

            // Historical roads (ML-detected from historical maps)
            // Rendered below modern roads, with temporal filtering
            {
                id: 'roads-historical-background',
                type: 'line',
                source: 'roads-temporal',
                filter: createRoadFilter(year),
                layout: {
                    'visibility': layerVisibility.roadsHistorical ? 'visible' : 'none',
                    'line-cap': 'round',
                    'line-join': 'round'
                },
                paint: {
                    'line-color': '#ffffff',
                    'line-width': [
                        'interpolate',
                        ['exponential', 1.5],
                        ['zoom'],
                        10, 2,
                        14, 5
                    ],
                    'line-opacity': 0.6
                }
            },
            // Removed roads layer (dashed, rendered first/below)
            {
                id: 'roads-historical-removed',
                type: 'line',
                source: 'roads-temporal',
                filter: ['all', createRoadFilter(year), ['==', ['get', 'ct'], 'removed']],
                layout: {
                    'visibility': layerVisibility.roadsHistorical ? 'visible' : 'none',
                    'line-cap': 'round',
                    'line-join': 'round'
                },
                paint: {
                    'line-color': '#dc2626',  // Red
                    'line-width': [
                        'interpolate',
                        ['exponential', 1.5],
                        ['zoom'],
                        10, 1.5,
                        14, 3.5
                    ],
                    'line-opacity': 0.6,
                    'line-dasharray': [2, 2]
                }
            },
            // Active roads layer (solid lines, excludes removed)
            {
                id: 'roads-historical',
                type: 'line',
                source: 'roads-temporal',
                filter: ['all', createRoadFilter(year), ['!=', ['get', 'ct'], 'removed']],
                layout: {
                    'visibility': layerVisibility.roadsHistorical ? 'visible' : 'none',
                    'line-cap': 'round',
                    'line-join': 'round'
                },
                paint: {
                    // Color by change type
                    'line-color': [
                        'match',
                        ['get', 'ct'],
                        'same', '#888888',      // Neutral gray
                        'widened', '#4a90d9',   // Blue
                        'rerouted', '#d97706',  // Orange
                        'replaced', '#7c3aed',  // Purple
                        'new', '#16a34a',       // Green
                        '#888888'               // Default: neutral gray
                    ],
                    'line-width': [
                        'interpolate',
                        ['exponential', 1.5],
                        ['zoom'],
                        10, 1.5,
                        14, 3.5
                    ],
                    // Opacity based on evidence strength
                    'line-opacity': [
                        'case',
                        ['==', ['get', 'ev'], 'h'], 0.9,
                        ['==', ['get', 'ev'], 'm'], 0.7,
                        0.5
                    ]
                }
            },

            // Buildings with era-based evidence filtering
            // Rules:
            // - Pre-1900: Need strong evidence (ev='h') AND sd <= year
            // - 1900-1950: Need strong evidence OR (in modern map)
            // - Post-1950: Show all modern buildings
            {
                id: 'buildings',
                type: 'fill',
                source: 'buildings-dated',
                'source-layer': 'buildings',
                filter: createBuildingFilter(year),
                layout: {
                    'visibility': layerVisibility.buildings ? 'visible' : 'none'
                },
                paint: {
                    // Color by evidence source
                    'fill-color': [
                        'case',
                        // Manual (researcher verified) - green
                        ['==', ['get', 'src'], 'man'],
                        '#2ecc71',
                        // SEFRAK buildings (historical colors by age)
                        ['==', ['get', 'src'], 'sef'],
                        [
                            'interpolate',
                            ['linear'],
                            ['coalesce', ['get', 'sd'], 1850],
                            1700, '#8b6914',  // Very old - dark ochre
                            1800, '#a67c2c',  // 1800s - medium brown
                            1850, '#b89968',  // Mid 1800s - tan
                            1900, '#c9a876'   // Late 1800s - light tan
                        ],
                        // ML-verified buildings (brown)
                        ['==', ['get', 'src'], 'ml'],
                        '#8b4513',
                        // Default (modern/unknown)
                        '#d4a373'
                    ],
                    'fill-opacity': [
                        'case',
                        ['==', ['get', 'ev'], 'h'], 0.85,
                        0.7
                    ]
                }
            },
            {
                id: 'buildings-outline',
                type: 'line',
                source: 'buildings-dated',
                'source-layer': 'buildings',
                filter: createBuildingFilter(year),
                layout: {
                    'visibility': layerVisibility.buildings ? 'visible' : 'none'
                },
                paint: {
                    'line-color': [
                        'case',
                        ['==', ['get', 'src'], 'man'], '#1a8c4a',  // Dark green for manual
                        ['==', ['get', 'src'], 'ml'], '#5c2e0d',
                        ['==', ['get', 'src'], 'sef'], '#5c4a1c',
                        '#8b6f47'
                    ],
                    'line-width': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        12, 0.5,
                        16, 1
                    ],
                    'line-opacity': 0.8
                }
            },

            // Confidence overlay - Red (low) to Green (high)
            // Shows evidence strength for all buildings
            {
                id: 'confidence-overlay',
                type: 'fill',
                source: 'buildings-dated',
                'source-layer': 'buildings',
                filter: createBuildingFilter(year),
                layout: {
                    'visibility': layerVisibility.confidenceOverlay ? 'visible' : 'none'
                },
                paint: {
                    'fill-color': [
                        'case',
                        // High evidence with ML confidence score
                        ['has', 'mlc'],
                        [
                            'interpolate',
                            ['linear'],
                            ['get', 'mlc'],
                            0.0, '#ff0000',
                            0.5, '#ffff00',
                            0.8, '#00ff00'
                        ],
                        // High evidence from SEFRAK/registry = green
                        ['==', ['get', 'ev'], 'h'],
                        '#00cc00',
                        // Low evidence = red
                        '#ff4444'
                    ],
                    'fill-opacity': 0.5
                }
            },

            // Finn.no property listings (point markers)
            // NOTE: FINN dates are now merged into OSM buildings - dots disabled
            {
                id: 'finn-markers',
                type: 'circle',
                source: 'finn-buildings',
                filter: [
                    'all',
                    ['<=', ['get', 'sd'], year],
                    ['any',
                        ['!', ['has', 'ed']],
                        ['>=', ['get', 'ed'], year]
                    ]
                ],
                layout: {
                    'visibility': 'none'  // Disabled - FINN data now merged into buildings
                },
                paint: {
                    'circle-radius': 8,
                    'circle-color': '#e91e63',
                    'circle-stroke-color': '#ffffff',
                    'circle-stroke-width': 2,
                    'circle-opacity': 0.9
                }
            },

            // Place labels
            {
                id: 'place-labels',
                type: 'symbol',
                source: 'trondheim',
                'source-layer': 'place',
                filter: createTemporalFilter(year),
                layout: {
                    'text-field': ['get', 'name'],
                    'text-font': ['Open Sans Regular'],
                    'text-size': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        10, 10,
                        14, 14
                    ],
                    'text-anchor': 'center'
                },
                paint: {
                    'text-color': '#333333',
                    'text-halo-color': '#ffffff',
                    'text-halo-width': 2
                }
            }
        ]
    };
}

/**
 * Create a temporal filter expression for MapLibre
 * Features are visible if: start_date <= year AND (end_date >= year OR end_date is null)
 * @param {number} year - The year to filter by
 * @returns {array} MapLibre filter expression
 */
function createTemporalFilter(year) {
    return [
        'all',
        // start_date <= year OR start_date doesn't exist (show features without start_date)
        [
            'any',
            ['!has', 'start_date'],
            ['<=', 'start_date', year]
        ],
        // end_date >= year OR end_date doesn't exist (show features without end_date or still existing)
        [
            'any',
            ['!has', 'end_date'],
            ['>=', 'end_date', year]
        ]
    ];
}

/**
 * Create source filter expression
 * @returns {array} MapLibre filter expression for enabled sources
 */
function createSourceFilter() {
    const enabledSources = Object.entries(sourceFilter)
        .filter(([_, enabled]) => enabled)
        .map(([src, _]) => src);

    if (enabledSources.length === 0) {
        // No sources enabled - show nothing
        return ['==', ['get', 'src'], '__none__'];
    }

    if (enabledSources.length === Object.keys(sourceFilter).length) {
        // All sources enabled - no filter needed
        return null;
    }

    // Filter to only enabled sources using 'match' for compatibility
    // ['match', input, value1, true, value2, true, ..., false]
    const matchArgs = ['match', ['get', 'src']];
    enabledSources.forEach(src => {
        matchArgs.push(src, true);
    });
    matchArgs.push(false);  // default
    return matchArgs;
}

/**
 * Create ML sub-source filter expression
 * @returns {array} MapLibre filter expression for ML sub-sources
 */
function createMlSourceFilter() {
    if (!sourceFilter.ml) {
        // ML disabled - main source filter handles it
        return null;
    }

    const enabledMlSources = Object.entries(mlSourceFilter)
        .filter(([_, enabled]) => enabled)
        .map(([src, _]) => src);

    if (enabledMlSources.length === Object.keys(mlSourceFilter).length) {
        // All ML sources enabled - no additional filter needed
        return null;
    }

    if (enabledMlSources.length === 0) {
        // No ML sources enabled - exclude all ML buildings
        return ['!=', ['get', 'src'], 'ml'];
    }

    // For ML buildings, check ml_src is in enabled list
    // For non-ML buildings, always pass
    // Note: If ml_src property doesn't exist, show all ML buildings (backward compatibility)
    const matchArgs = ['match', ['get', 'ml_src']];
    enabledMlSources.forEach(src => {
        matchArgs.push(src, true);
    });
    matchArgs.push(false);  // default

    return [
        'any',
        ['!=', ['get', 'src'], 'ml'],
        ['!', ['has', 'ml_src']],
        matchArgs
    ];
}

/**
 * Create building filter with dual-mode logic
 *
 * Type A (Date Sources): Timeline-aware filtering
 * - Buildings from sef, mat, tk, man, finn, osm
 * - Show if: source is enabled AND sd <= year AND (ed is null OR ed >= year)
 *
 * Type B (Snapshot Sources): Static display
 * - ML-detected buildings from kv1880, kv1904, air1947
 * - Show if: snapshot source is enabled (ignores timeline)
 *
 * @param {number} year - The year to filter by (applies to Type A only)
 * @returns {array} MapLibre filter expression
 */
function createBuildingFilter(year) {
    // Temporal filter: building existed at the given year
    // Case 1: Building has sd - show if sd <= year AND (no ed OR ed >= year)
    // Case 2: Building has no sd - fallback: show only for years >= 1960
    // Note: Using legacy filter syntax (property names as strings)
    // Note: Buildings use '_src' field (with underscore)
    const FALLBACK_YEAR = 1960;

    const hasDateFilter = [
        'all',
        ['has', 'sd'],
        ['<=', 'sd', year],
        ['any',
            ['!has', 'ed'],
            ['>=', 'ed', year]
        ]
    ];

    // Build temporal filter - include undated buildings only if year >= fallback
    let temporalFilter;
    if (year >= FALLBACK_YEAR) {
        // Show buildings with dates OR buildings without dates
        temporalFilter = ['any', hasDateFilter, ['!has', 'sd']];
    } else {
        // Only show buildings with dates in range
        temporalFilter = hasDateFilter;
    }

    // If source filter is disabled (production mode), just apply temporal filter
    if (!sourceFilterEnabled) {
        return temporalFilter;
    }

    // === When filter is enabled, also apply source filtering ===
    const conditions = [];

    // Type A: Date Sources (timeline-aware)
    const enabledDateSources = Object.entries(dateSourceFilter)
        .filter(([_, enabled]) => enabled)
        .map(([src, _]) => src);

    if (enabledDateSources.length > 0) {
        // Source filter using _src field
        const dateSourceFilterExpr = ['in', '_src', ...enabledDateSources];
        conditions.push(['all', dateSourceFilterExpr, temporalFilter]);
    }

    // Type B: Snapshot Sources (static - ignores timeline)
    const enabledSnapshots = Object.entries(snapshotFilter)
        .filter(([_, enabled]) => enabled)
        .map(([src, _]) => src);

    if (enabledSnapshots.length > 0) {
        // Snapshot buildings have _src='ml' and ml_src specifies which snapshot
        const snapshotFilterExpr = [
            'all',
            ['==', '_src', 'ml'],
            ['in', 'ml_src', ...enabledSnapshots]
        ];
        conditions.push(snapshotFilterExpr);
    }

    // Combine Type A and Type B with OR
    if (conditions.length === 0) {
        return ['==', '_src', '__none__']; // Always false
    } else if (conditions.length === 1) {
        return conditions[0];
    } else {
        return ['any', ...conditions];
    }
}

/**
 * Create road source filter expression
 * Roads use 'src' field with values: nvdb, osm, kult, ml
 * ML roads also have 'ml_src' for specific map source: kv1880, kv1904, air1947
 * @returns {array} MapLibre filter expression for enabled road sources
 */
function createRoadSourceFilter() {
    const enabledSources = Object.entries(roadSourceFilter)
        .filter(([_, enabled]) => enabled)
        .map(([src, _]) => src);

    if (enabledSources.length === 0) {
        // No sources enabled - show nothing
        return ['==', ['get', 'src'], '__none__'];
    }

    if (enabledSources.length === Object.keys(roadSourceFilter).length) {
        // All sources enabled - no filter needed
        return null;
    }

    // Build filter conditions
    const conditions = [];

    // NVDB roads (src = 'nvdb')
    if (roadSourceFilter.nvdb) {
        conditions.push(['==', ['get', 'src'], 'nvdb']);
    }

    // Kulturminnesøk roads (src = 'kult')
    if (roadSourceFilter.kult) {
        conditions.push(['==', ['get', 'src'], 'kult']);
    }

    // OSM roads (src = 'osm')
    if (roadSourceFilter.osm) {
        conditions.push(['==', ['get', 'src'], 'osm']);
    }

    // ML roads - check individual map sources
    const mlSources = [];
    if (roadSourceFilter.ml_kv1880) mlSources.push('kv1880');
    if (roadSourceFilter.ml_kv1904) mlSources.push('kv1904');
    if (roadSourceFilter.ml_air1947) mlSources.push('air1947');

    if (mlSources.length > 0) {
        // ML roads have src='ml' and ml_src specifies the map
        // Use 'match' instead of 'in' + 'literal' for MapLibre compatibility
        const mlMatchArgs = ['match', ['get', 'ml_src']];
        mlSources.forEach(src => {
            mlMatchArgs.push(src, true);
        });
        mlMatchArgs.push(false);  // default

        conditions.push([
            'all',
            ['==', ['get', 'src'], 'ml'],
            mlMatchArgs
        ]);
    }

    if (conditions.length === 0) {
        return ['==', ['get', 'src'], '__none__'];
    }

    if (conditions.length === 1) {
        return conditions[0];
    }

    return ['any', ...conditions];
}

/**
 * Create road type filter expression
 * Roads use 'rt' field with values: motorway, primary, secondary, tertiary, residential, path, historical
 * @returns {array} MapLibre filter expression for enabled road types
 */
function createRoadTypeFilter() {
    const enabledTypes = Object.entries(roadTypeFilter)
        .filter(([_, enabled]) => enabled)
        .map(([type, _]) => type);

    if (enabledTypes.length === 0) {
        return ['==', ['get', 'rt'], '__none__'];
    }

    if (enabledTypes.length === Object.keys(roadTypeFilter).length) {
        // All types enabled - no filter needed
        return null;
    }

    // Use 'match' instead of 'in' + 'literal' for MapLibre compatibility
    const matchArgs = ['match', ['get', 'rt']];
    enabledTypes.forEach(type => {
        matchArgs.push(type, true);
    });
    matchArgs.push(false);  // default
    return matchArgs;
}

/**
 * Create road date range filter expression
 * Filters roads where sd (start_date) falls within the specified range
 * @returns {array} MapLibre filter expression for date range
 */
function createRoadDateRangeFilter() {
    // If full range, no filter needed
    if (roadDateRange.from <= 1700 && roadDateRange.to >= 2025) {
        return null;
    }

    // Filter: sd >= from AND sd <= to (or no sd means modern/unknown)
    return [
        'any',
        // Roads without dates (modern/unknown) - always show
        ['==', ['has', 'sd'], false],
        // Roads with dates in range
        [
            'all',
            ['>=', ['get', 'sd'], roadDateRange.from],
            ['<=', ['get', 'sd'], roadDateRange.to]
        ]
    ];
}

/**
 * Create temporal and era-based filter for roads
 * Rules:
 * - Show roads if sd <= currentYear (road existed by this year)
 * - Hide removed roads if ed <= currentYear (road was removed by this year)
 * - Post-1950: show all roads
 * - 1900-1950: show if has evidence OR no date (modern)
 * - Pre-1900: only show with evidence AND sd <= year
 * @param {number} year - The year to filter by
 * @returns {array} MapLibre filter expression
 */
function createRoadFilter(year) {
    // Build temporal filter (sd <= year AND (ed is null OR ed > year))
    // Note: Removed roads should hide when ed <= year
    const temporalFilter = [
        'all',
        // start_date <= year OR no start_date (show modern roads)
        [
            'any',
            ['==', ['has', 'sd'], false],
            ['<=', ['get', 'sd'], year]
        ],
        // end_date > year OR no end_date (road still exists at this year)
        // Changed from >= to > so roads hide in the year they were removed
        [
            'any',
            ['==', ['has', 'ed'], false],
            ['>', ['get', 'ed'], year]
        ]
    ];

    // Build source filter
    const srcFilter = createRoadSourceFilter();

    // Build road type filter
    const typeFilter = createRoadTypeFilter();

    // Build date range filter
    const dateRangeFilter = createRoadDateRangeFilter();

    // Build era-based filter (similar to buildings but using road evidence)
    let eraFilter;
    if (year >= 1950) {
        // Post-1950: show all roads
        eraFilter = null;
    } else if (year >= 1900) {
        // 1900-1950: show if has evidence with sd <= year, or modern (no date)
        eraFilter = [
            'any',
            ['==', ['has', 'sd'], false],
            [
                'all',
                ['any', ['==', ['get', 'ev'], 'h'], ['==', ['get', 'ev'], 'm']],
                ['<=', ['get', 'sd'], year]
            ]
        ];
    } else {
        // Pre-1900: only show with high evidence AND sd <= year
        eraFilter = [
            'all',
            ['==', ['get', 'ev'], 'h'],
            ['has', 'sd'],
            ['<=', ['get', 'sd'], year]
        ];
    }

    // Combine filters - only include non-null filters
    const filters = [temporalFilter, srcFilter, typeFilter, dateRangeFilter, eraFilter].filter(f => f !== null);

    if (filters.length === 0) {
        return true;
    } else if (filters.length === 1) {
        return filters[0];
    } else {
        return ['all', ...filters];
    }
}

/**
 * Initialize the map
 */
function initMap() {
    console.log('Initializing map...');

    try {
        map = new maplibregl.Map({
            container: 'map',
            style: createMapStyle(currentYear),
            center: CONFIG.center,
            zoom: CONFIG.zoom,
            minZoom: CONFIG.minZoom,
            maxZoom: CONFIG.maxZoom,
            attributionControl: true
        });

        // Add navigation controls
        map.addControl(new maplibregl.NavigationControl(), 'bottom-right');

        // Add scale control
        map.addControl(new maplibregl.ScaleControl({
            maxWidth: 200,
            unit: 'metric'
        }), 'bottom-left');

        // Map load event
        map.on('load', () => {
            console.log('Map loaded successfully');

            // DEBUG: Log available sources
            const style = map.getStyle();
            console.log('Available sources:', Object.keys(style.sources));

            // DEBUG: Check if buildings source has data
            const buildingsSource = map.getSource('buildings-dated');
            if (buildingsSource) {
                console.log('Buildings source type:', buildingsSource.type);
                // For GeoJSON sources, check if data is loaded
                if (buildingsSource._data) {
                    const featureCount = buildingsSource._data.features ?
                        buildingsSource._data.features.length : 'N/A';
                    console.log('Buildings feature count:', featureCount);
                }
            } else {
                console.error('Buildings source not found!');
            }

            // DEBUG: Check if buildings layer exists
            const buildingsLayer = map.getLayer('buildings');
            if (buildingsLayer) {
                console.log('Buildings layer exists, visibility:',
                    map.getLayoutProperty('buildings', 'visibility'));
                console.log('Buildings layer filter:', map.getFilter('buildings'));
            } else {
                console.error('Buildings layer not found!');
            }

            // Initialize manual edits overlay layer
            initManualEditsLayer();

            // Load manual edits data
            loadManualEdits();

            hideLoading();

            // Add click handler for roads
            map.on('click', 'roads-historical', (e) => {
                if (e.features.length > 0) {
                    const props = e.features[0].properties;

                    // Map change type codes to human-readable labels
                    const changeTypeLabels = {
                        'same': 'Unchanged',
                        'widened': 'Widened',
                        'rerouted': 'Rerouted',
                        'replaced': 'Replaced',
                        'removed': 'Removed',
                        'new': 'New'
                    };

                    // Map date method codes to human-readable labels
                    const dateMethodLabels = {
                        'direct': 'Direct dating',
                        'inferred': 'Inferred from map',
                        'estimated': 'Estimated',
                        'unknown': 'Unknown method'
                    };

                    const changeType = changeTypeLabels[props.ct] || props.ct || 'Unknown';
                    const dateMethod = dateMethodLabels[props.sd_method] || props.sd_method || 'Unknown';

                    const html = `
                        <div style="max-width: 280px; font-family: system-ui, sans-serif;">
                            <h3 style="margin: 0 0 8px 0; color: #2c3e50;">${props.nm || 'Road'}</h3>
                            <p style="margin: 4px 0;"><strong>Change type:</strong> <span style="color: ${getChangeTypeColor(props.ct)}">${changeType}</span></p>
                            ${props.sd ? `<p style="margin: 4px 0;"><strong>Construction year:</strong> ${props.sd}</p>` : ''}
                            ${props.ed ? `<p style="margin: 4px 0;"><strong>End year:</strong> ${props.ed}</p>` : ''}
                            ${props.sd_method ? `<p style="margin: 4px 0;"><strong>Date method:</strong> ${dateMethod}</p>` : ''}
                            ${props.ev ? `<p style="margin: 4px 0;"><strong>Evidence:</strong> ${getEvidenceLabel(props.ev)}</p>` : ''}
                        </div>
                    `;

                    new maplibregl.Popup({ closeButton: true, maxWidth: '300px' })
                        .setLngLat(e.lngLat)
                        .setHTML(html)
                        .addTo(map);
                }
            });

            // Change cursor on hover for roads
            map.on('mouseenter', 'roads-historical', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'roads-historical', () => {
                map.getCanvas().style.cursor = '';
            });

            // Add click handler for removed roads (same popup logic)
            map.on('click', 'roads-historical-removed', (e) => {
                if (e.features.length > 0) {
                    const props = e.features[0].properties;
                    const html = `
                        <div style="max-width: 280px; font-family: system-ui, sans-serif;">
                            <h3 style="margin: 0 0 8px 0; color: #dc2626;">${props.nm || 'Road'}</h3>
                            <p style="margin: 4px 0;"><strong>Status:</strong> <span style="color: #dc2626">Removed</span></p>
                            ${props.sd ? `<p style="margin: 4px 0;"><strong>Construction year:</strong> ${props.sd}</p>` : ''}
                            ${props.ed ? `<p style="margin: 4px 0;"><strong>Removed:</strong> ${props.ed}</p>` : ''}
                            ${props.ev ? `<p style="margin: 4px 0;"><strong>Evidence:</strong> ${getEvidenceLabel(props.ev)}</p>` : ''}
                        </div>
                    `;
                    new maplibregl.Popup({ closeButton: true, maxWidth: '300px' })
                        .setLngLat(e.lngLat)
                        .setHTML(html)
                        .addTo(map);
                }
            });
            map.on('mouseenter', 'roads-historical-removed', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'roads-historical-removed', () => {
                map.getCanvas().style.cursor = '';
            });

            // Add click handler for Finn markers
            map.on('click', 'finn-markers', (e) => {
                if (e.features.length > 0) {
                    const props = e.features[0].properties;
                    const raw = props._raw ? JSON.parse(props._raw) : {};

                    const html = `
                        <div style="max-width: 280px; font-family: system-ui, sans-serif;">
                            <h3 style="margin: 0 0 8px 0; color: #e91e63;">${props.nm || 'Unknown'}</h3>
                            <p style="margin: 4px 0;"><strong>Built:</strong> ${props.sd || 'Unknown'}</p>
                            ${raw.price ? `<p style="margin: 4px 0;"><strong>Listed price:</strong> ${raw.price.toLocaleString('no-NO')} kr</p>` : ''}
                            ${raw.size_m2 ? `<p style="margin: 4px 0;"><strong>Size:</strong> ${raw.size_m2} m²</p>` : ''}
                            ${raw.property_type ? `<p style="margin: 4px 0;"><strong>Type:</strong> ${raw.property_type}</p>` : ''}
                            ${raw.link ? `<p style="margin: 8px 0 0 0;"><a href="${raw.link}" target="_blank" style="color: #e91e63;">View on Finn.no →</a></p>` : ''}
                        </div>
                    `;

                    new maplibregl.Popup({ closeButton: true, maxWidth: '300px' })
                        .setLngLat(e.lngLat)
                        .setHTML(html)
                        .addTo(map);
                }
            });

            // Change cursor on hover
            map.on('mouseenter', 'finn-markers', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'finn-markers', () => {
                map.getCanvas().style.cursor = '';
            });

            // Add click handler for buildings (edit mode)
            map.on('click', 'buildings', (e) => {
                handleBuildingClickForEdit(e);
            });

            // Change cursor on hover for buildings (when in edit mode)
            map.on('mouseenter', 'buildings', () => {
                if (editMode) {
                    map.getCanvas().style.cursor = 'pointer';
                }
            });
            map.on('mouseleave', 'buildings', () => {
                if (editMode) {
                    map.getCanvas().style.cursor = 'pointer';
                }
            });
        });

        // Error handling
        map.on('error', (e) => {
            console.error('Map error:', e);
            // Don't show error for missing tiles - this is expected if PMTiles doesn't exist yet
            if (e.error && e.error.message && !e.error.message.includes('404')) {
                showError('Map error: ' + e.error.message);
            }
        });


        // DEBUG: Log when source data loads
        map.on('sourcedata', (e) => {
            if (e.sourceId === 'buildings-dated' && e.isSourceLoaded) {
                console.log('Buildings source fully loaded');
                const source = map.getSource('buildings-dated');
                if (source && source._data && source._data.features) {
                    console.log('Loaded', source._data.features.length, 'building features');
                }
            }
        });

    } catch (error) {
        console.error('Failed to initialize map:', error);
        showError('Failed to initialize map: ' + error.message);
        hideLoading();
    }
}

/**
 * Update the map to show features from a specific year
 * @param {number} year - The year to display
 */
function updateMapYear(year) {
    if (!map) {
        console.warn('Map not initialized yet');
        return;
    }

    currentYear = year;

    try {
        // Update filters directly on existing layers instead of recreating style
        if (map.isStyleLoaded()) {
            updateLayerFilters(year);
        } else {
            // If style not loaded yet, set full style
            const newStyle = createMapStyle(year);
            map.setStyle(newStyle);
        }

        // Update the year display
        document.getElementById('currentYear').textContent = year;

        // Update era indicator
        updateEraIndicator(year);

    } catch (error) {
        console.error('Failed to update map year:', error);
        showError('Failed to update year: ' + error.message);
    }
}

/**
 * Update layer filters without recreating the entire style
 * This is much faster than setStyle() as it doesn't reload data sources
 * @param {number} year - The year to filter by
 */
function updateLayerFilters(year) {
    const style = getHistoricalStyle(year);

    // Update temporal filters on PMTiles layers
    const temporalFilter = createTemporalFilter(year);
    const pmtilesLayers = ['water', 'water-outline', 'landuse', 'roads-background', 'roads'];

    pmtilesLayers.forEach(layerId => {
        if (map.getLayer(layerId)) {
            try {
                const currentFilter = map.getFilter(layerId);
                // For roads, combine with class filter
                if (layerId === 'roads-background' || layerId === 'roads') {
                    map.setFilter(layerId, ['all', temporalFilter, ['in', 'class', 'motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'minor', 'service']]);
                } else {
                    map.setFilter(layerId, temporalFilter);
                }
            } catch (e) {
                // Layer might not exist
            }
        }
    });

    // Update building filters
    const buildingFilter = createBuildingFilter(year);
    ['buildings', 'buildings-outline', 'confidence-overlay'].forEach(layerId => {
        if (map.getLayer(layerId)) {
            map.setFilter(layerId, buildingFilter);
        }
    });

    // Update historical road filters
    const roadFilter = createRoadFilter(year);
    ['roads-historical-background', 'roads-historical', 'roads-historical-removed'].forEach(layerId => {
        if (map.getLayer(layerId)) {
            // For removed roads, combine base filter with ct='removed' check
            if (layerId === 'roads-historical-removed') {
                map.setFilter(layerId, ['all', roadFilter, ['==', ['get', 'ct'], 'removed']]);
            } else if (layerId === 'roads-historical') {
                map.setFilter(layerId, ['all', roadFilter, ['!=', ['get', 'ct'], 'removed']]);
            } else {
                map.setFilter(layerId, roadFilter);
            }
        }
    });

    // Finn markers disabled - FINN dates now merged into main buildings layer
    // Keep layer hidden regardless of filter settings
    if (map.getLayer('finn-markers')) {
        map.setLayoutProperty('finn-markers', 'visibility', 'none');
    }

    // Update background color for historical styling
    if (map.getLayer('background')) {
        map.setPaintProperty('background', 'background-color', style.backgroundColor);
    }

    // Update water color
    if (map.getLayer('water')) {
        map.setPaintProperty('water', 'fill-color', style.waterColor);
    }
}

/**
 * Toggle layer visibility
 * @param {string} layerName - Name of layer to toggle
 */
function toggleLayer(layerName) {
    if (layerName in layerVisibility) {
        layerVisibility[layerName] = !layerVisibility[layerName];
        const visibility = layerVisibility[layerName] ? 'visible' : 'none';

        // Update layer visibility directly instead of recreating style
        if (map && map.isStyleLoaded()) {
            const layerMapping = {
                buildings: ['buildings', 'buildings-outline'],
                roads: ['roads', 'roads-background'],
                roadsHistorical: ['roads-historical', 'roads-historical-background', 'roads-historical-removed'],
                water: ['water', 'water-outline'],
                confidenceOverlay: ['confidence-overlay']
            };

            const layers = layerMapping[layerName] || [];
            layers.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', visibility);
                }
            });
        }

        console.log(`Layer ${layerName} visibility:`, layerVisibility[layerName]);
    }
}

/**
 * Enter source inspection mode
 * Shows only features from a specific ML source with confidence coloring
 * @param {string} sourceId - Source ID ('kv1880', 'kv1904', 'air1947')
 */
function enterInspectionMode(sourceId) {
    if (!historicalMapSources || !historicalMapSources[sourceId]) {
        console.error('Unknown source or manifest not loaded:', sourceId);
        return;
    }

    inspectionMode.active = true;
    inspectionMode.source = sourceId;

    console.log('Entering inspection mode for source:', sourceId);

    // Update UI
    const overlay = document.getElementById('inspectionOverlay');
    if (overlay) {
        overlay.classList.add('active');
        document.getElementById('inspectionSourceName').textContent =
            historicalMapSources[sourceId].name;
    }

    // Update map with inspection style
    updateInspectionView();
}

/**
 * Exit source inspection mode
 */
function exitInspectionMode() {
    inspectionMode.active = false;
    inspectionMode.source = null;

    console.log('Exiting inspection mode');

    // Update UI
    const overlay = document.getElementById('inspectionOverlay');
    if (overlay) {
        overlay.classList.remove('active');
    }

    // Restore normal map view
    updateMapYear(currentYear);
}

/**
 * Update the map view for inspection mode
 */
function updateInspectionView() {
    if (!map || !inspectionMode.active || !inspectionMode.source) return;

    const sourceId = inspectionMode.source;
    const sourceInfo = historicalMapSources[sourceId];

    // Create inspection-specific style
    const style = createInspectionStyle(sourceId);
    map.setStyle(style);

    // Update statistics
    updateInspectionStats(sourceId);
}

/**
 * Create map style for inspection mode
 * Shows historical map raster + confidence-colored detections
 * @param {string} sourceId - Source ID
 * @returns {object} MapLibre style object
 */
function createInspectionStyle(sourceId) {
    const sourceInfo = historicalMapSources[sourceId];
    const mlSrcValue = sourceId;  // 'kv1880', 'kv1904', 'air1947'

    // Build sources based on historical map type
    const sources = {
        // Buildings with dates
        'buildings-dated': {
            type: 'vector',
            url: `pmtiles://${CONFIG.buildingsPath}`
        },
        // Roads with dates
        'roads-temporal': {
            type: 'geojson',
            data: 'data/roads_temporal.geojson'
        }
    };

    // Build layers array
    const layers = [
        // Light background
        {
            id: 'background',
            type: 'background',
            paint: {
                'background-color': '#f5f5f5'
            }
        }
    ];

    // Add historical map source(s) and layer(s) based on type
    if (sourceInfo.type === 'tiles') {
        // XYZ tile source
        sources['historical-raster'] = {
            type: 'raster',
            tiles: sourceInfo.tiles,
            tileSize: 256,
            bounds: sourceInfo.bounds,
            minzoom: sourceInfo.minzoom || 8,
            maxzoom: sourceInfo.maxzoom || 18,
            attribution: sourceInfo.attribution
        };
        layers.push({
            id: 'historical-map',
            type: 'raster',
            source: 'historical-raster',
            paint: { 'raster-opacity': 0.7 }
        });
    } else if (sourceInfo.type === 'image') {
        // Single georeferenced image
        // MapLibre image source needs coordinates as [[W,N], [E,N], [E,S], [W,S]]
        const [west, south, east, north] = sourceInfo.bounds;
        sources['historical-image'] = {
            type: 'image',
            url: sourceInfo.url,
            coordinates: [
                [west, north],  // top-left
                [east, north],  // top-right
                [east, south],  // bottom-right
                [west, south]   // bottom-left
            ]
        };
        layers.push({
            id: 'historical-map',
            type: 'raster',
            source: 'historical-image',
            paint: { 'raster-opacity': 0.7 }
        });
    } else if (sourceInfo.type === 'mosaic') {
        // Multiple georeferenced images forming one map
        sourceInfo.images.forEach((img, idx) => {
            const [west, south, east, north] = img.bounds;
            sources[`historical-mosaic-${idx}`] = {
                type: 'image',
                url: img.url,
                coordinates: [
                    [west, north],
                    [east, north],
                    [east, south],
                    [west, south]
                ]
            };
            layers.push({
                id: `historical-map-${idx}`,
                type: 'raster',
                source: `historical-mosaic-${idx}`,
                paint: { 'raster-opacity': 0.7 }
            });
        });
    }

    // Add feature layers (buildings and roads with confidence coloring)
    layers.push(
        // Buildings from this source - colored by confidence
        {
            id: 'inspection-buildings',
            type: 'fill',
            source: 'buildings-dated',
            'source-layer': 'buildings',
            filter: createInspectionFilter('building', mlSrcValue),
            paint: {
                // Confidence-based coloring: red (low) -> yellow (mid) -> green (high)
                'fill-color': [
                    'case',
                    ['has', 'mlc'],
                    [
                        'interpolate',
                        ['linear'],
                        ['get', 'mlc'],
                        0.0, '#ff0000',   // Red - low confidence
                        0.5, '#ffaa00',   // Orange
                        0.7, '#ffff00',   // Yellow
                        0.85, '#88ff00',  // Light green
                        1.0, '#00ff00'    // Green - high confidence
                    ],
                    '#888888'  // Gray if no confidence score
                ],
                'fill-opacity': 0.8
            }
        },
        {
            id: 'inspection-buildings-outline',
            type: 'line',
            source: 'buildings-dated',
            'source-layer': 'buildings',
            filter: createInspectionFilter('building', mlSrcValue),
            paint: {
                'line-color': '#333333',
                'line-width': 1.5
            }
        },
        // Roads from this source - colored by confidence
        {
            id: 'inspection-roads-background',
            type: 'line',
            source: 'roads-temporal',
            filter: createInspectionFilter('road', mlSrcValue),
            layout: {
                'line-cap': 'round',
                'line-join': 'round'
            },
            paint: {
                'line-color': '#ffffff',
                'line-width': 6,
                'line-opacity': 0.8
            }
        },
        {
            id: 'inspection-roads',
            type: 'line',
            source: 'roads-temporal',
            filter: createInspectionFilter('road', mlSrcValue),
            layout: {
                'line-cap': 'round',
                'line-join': 'round'
            },
            paint: {
                // Confidence-based coloring
                'line-color': [
                    'case',
                    ['has', 'mlc'],
                    [
                        'interpolate',
                        ['linear'],
                        ['get', 'mlc'],
                        0.0, '#ff0000',
                        0.5, '#ffaa00',
                        0.7, '#ffff00',
                        0.85, '#88ff00',
                        1.0, '#00ff00'
                    ],
                    '#888888'
                ],
                'line-width': 4
            }
        }
    );

    return {
        version: 8,
        name: `Inspection - ${sourceInfo.name}`,
        glyphs: 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
        sources: sources,
        layers: layers
    };
}

/**
 * Create filter for inspection mode - only show features from specific ML source
 * @param {string} featureType - 'building' or 'road'
 * @param {string} mlSrcValue - ML source value ('kv1880', 'kv1904', 'air1947')
 * @returns {array} MapLibre filter expression
 */
function createInspectionFilter(featureType, mlSrcValue) {
    // Filter to features that have this ml_src value
    return [
        'all',
        ['==', ['get', 'src'], 'ml'],
        ['==', ['get', 'ml_src'], mlSrcValue]
    ];
}

/**
 * Update historical map opacity in inspection mode
 * @param {number} value - Opacity value 0-100
 */
function updateHistoricalMapOpacity(value) {
    if (!map || !inspectionMode.active) return;

    const opacity = value / 100;
    const sourceInfo = historicalMapSources[inspectionMode.source];

    try {
        // Update all historical map layers
        if (sourceInfo.type === 'tiles' || sourceInfo.type === 'image') {
            map.setPaintProperty('historical-map', 'raster-opacity', opacity);
        } else if (sourceInfo.type === 'mosaic') {
            sourceInfo.images.forEach((_, idx) => {
                const layerId = `historical-map-${idx}`;
                if (map.getLayer(layerId)) {
                    map.setPaintProperty(layerId, 'raster-opacity', opacity);
                }
            });
        }
    } catch (e) {
        console.warn('Could not update historical map opacity:', e);
    }
}

/**
 * Update inspection mode statistics
 * @param {string} sourceId - Source ID
 */
function updateInspectionStats(sourceId) {
    // Count features and calculate average confidence
    let buildingCount = 0;
    let roadCount = 0;
    let totalBuildingConf = 0;
    let totalRoadConf = 0;

    // Count from cached data if available
    if (buildingsDataCache && buildingsDataCache.features) {
        buildingsDataCache.features.forEach(f => {
            if (f.properties.src === 'ml' && f.properties.ml_src === sourceId) {
                buildingCount++;
                if (f.properties.mlc) {
                    totalBuildingConf += f.properties.mlc;
                }
            }
        });
    }

    if (roadsDataCache && roadsDataCache.features) {
        roadsDataCache.features.forEach(f => {
            if (f.properties.ml_src === sourceId) {
                roadCount++;
                if (f.properties.mlc) {
                    totalRoadConf += f.properties.mlc;
                }
            }
        });
    }

    const avgBuildingConf = buildingCount > 0 ? (totalBuildingConf / buildingCount).toFixed(2) : '-';
    const avgRoadConf = roadCount > 0 ? (totalRoadConf / roadCount).toFixed(2) : '-';

    // Update UI
    const statsEl = document.getElementById('inspectionStats');
    if (statsEl) {
        statsEl.innerHTML = `
            <div class="stat-row">
                <span class="stat-label">Buildings:</span>
                <span class="stat-value">${buildingCount}</span>
                <span class="stat-conf">avg conf: ${avgBuildingConf}</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Roads:</span>
                <span class="stat-value">${roadCount}</span>
                <span class="stat-conf">avg conf: ${avgRoadConf}</span>
            </div>
        `;
    }
}

/**
 * Start animation through years
 * @param {number} speed - Years per second (default: 5)
 */
function startAnimation(speed = 5) {
    if (isAnimating) {
        stopAnimation();
        return;
    }

    isAnimating = true;
    const startYear = currentYear;
    const startTime = Date.now();
    const btn = document.getElementById('playBtn');
    if (btn) btn.textContent = '⏸';

    function animate() {
        if (!isAnimating) return;

        const elapsed = (Date.now() - startTime) / 1000; // seconds
        const newYear = Math.floor(startYear + (elapsed * speed));

        if (newYear > CONFIG.maxYear) {
            stopAnimation();
            return;
        }

        currentYear = newYear;
        const slider = document.getElementById('yearSlider');
        if (slider) slider.value = currentYear;

        updateMapYear(currentYear);
        animationFrameId = requestAnimationFrame(animate);
    }

    animate();
}

/**
 * Stop year animation
 */
function stopAnimation() {
    isAnimating = false;
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    const btn = document.getElementById('playBtn');
    if (btn) btn.textContent = '▶';
}

/**
 * Step year forward or backward by delta
 * @param {number} delta - Number of years to step (+1 or -1)
 */
function stepYear(delta) {
    // Stop animation if running
    if (isAnimating) {
        stopAnimation();
    }

    // Calculate new year with bounds checking
    const newYear = Math.max(CONFIG.minYear, Math.min(CONFIG.maxYear, currentYear + delta));

    // Update if changed
    if (newYear !== currentYear) {
        currentYear = newYear;

        // Update slider
        const slider = document.getElementById('yearSlider');
        if (slider) {
            slider.value = currentYear;
        }

        // Update year display
        const yearDisplay = document.getElementById('currentYear');
        if (yearDisplay) {
            yearDisplay.textContent = currentYear;
        }

        // Update map
        updateMapYear(currentYear);
    }
}

/**
 * Update the era indicator with current year info
 * @param {number} year - Current year
 */
function updateEraIndicator(year) {
    const eraText = document.getElementById('eraText');
    const dataSource = document.getElementById('dataSource');
    const featureCount = document.getElementById('featureCount');

    if (eraText) {
        let era = '';
        if (year < 1750) era = 'Early 18th Century';
        else if (year < 1800) era = 'Late 18th Century';
        else if (year < 1850) era = 'Early 19th Century';
        else if (year < 1900) era = 'Late 19th Century';
        else if (year < 1950) era = 'Early 20th Century';
        else if (year < 2000) era = 'Late 20th Century';
        else era = '21st Century';

        eraText.textContent = era;
    }

    if (dataSource) {
        let sources = [];
        if (year < 1900) sources.push('SEFRAK (Riksantikvaren)');
        if (year >= 1800 && year < 1950) sources.push('Kartverket Historical');
        if (year >= 1950) sources.push('OpenStreetMap');
        dataSource.textContent = sources.join(' + ') || 'Mixed Sources';
    }

    // Feature count - count buildings from the buildings layer
    if (featureCount && map && map.isStyleLoaded()) {
        try {
            const features = map.queryRenderedFeatures({ layers: ['buildings'] });
            featureCount.textContent = `~${features.length} buildings visible`;
        } catch (e) {
            featureCount.textContent = 'Loading...';
        }
    }
}

/**
 * Initialize the time slider controls
 */
function initControls() {
    const slider = document.getElementById('yearSlider');
    const yearDisplay = document.getElementById('currentYear');

    if (!slider || !yearDisplay) {
        console.error('Controls elements not found');
        return;
    }

    // Set initial value
    slider.value = currentYear;
    yearDisplay.textContent = currentYear;

    // Handle slider input (fires continuously as user drags)
    slider.addEventListener('input', (e) => {
        const year = parseInt(e.target.value);
        yearDisplay.textContent = year;

        // Stop animation if slider is manually moved
        if (isAnimating) {
            stopAnimation();
        }
    });

    // Handle slider change (fires when user releases)
    slider.addEventListener('change', (e) => {
        const year = parseInt(e.target.value);
        updateMapYear(year);
    });

    // Play/Pause button
    const playBtn = document.getElementById('playBtn');
    if (playBtn) {
        playBtn.addEventListener('click', () => {
            if (isAnimating) {
                stopAnimation();
            } else {
                // Reset to start if at end
                if (currentYear >= CONFIG.maxYear) {
                    currentYear = CONFIG.minYear;
                    slider.value = currentYear;
                }
                startAnimation(5);
            }
        });
    }

    // Step back button
    const stepBackBtn = document.getElementById('stepBackBtn');
    if (stepBackBtn) {
        stepBackBtn.addEventListener('click', () => stepYear(-1));
    }

    // Step forward button
    const stepFwdBtn = document.getElementById('stepFwdBtn');
    if (stepFwdBtn) {
        stepFwdBtn.addEventListener('click', () => stepYear(1));
    }

    // Initialize minimal layer toggle buttons
    initLayerToggles();

    // Initialize collapsible section handlers (legacy)
    initSectionToggles();

    // Initialize base map layer toggles
    initBaseMapControls();

    // Initialize source filter controls (buildings)
    initSourceFilterControls();

    // Initialize road source controls (simplified)
    initRoadSourceControls();

    console.log('Controls initialized');
}

/**
 * Initialize minimal layer toggle buttons
 */
function initLayerToggles() {
    // Background toggle - hides roads, landuse, labels (but keeps water visible)
    const backgroundBtn = document.getElementById('toggleBackground');
    if (backgroundBtn) {
        backgroundBtn.addEventListener('click', () => {
            backgroundBtn.classList.toggle('active');
            const visible = backgroundBtn.classList.contains('active');
            toggleBackgroundLayers(visible);
        });
    }

    // Debug mode toggle - shows date sources with color coding
    const debugBtn = document.getElementById('toggleDebug');
    const debugLegend = document.getElementById('debugLegend');
    if (debugBtn) {
        debugBtn.addEventListener('click', () => {
            debugColorMode = !debugColorMode;
            debugBtn.classList.toggle('active', debugColorMode);
            console.log('Debug color mode:', debugColorMode ? 'ON' : 'OFF');

            // Show/hide legend
            if (debugLegend) {
                debugLegend.style.display = debugColorMode ? 'block' : 'none';
            }

            // Update building paint
            if (map && map.loaded()) {
                updateBuildingPaint();
            }
        });
    }

    // Edit mode toggle
    const editBtn = document.getElementById('toggleEdit');
    if (editBtn) {
        editBtn.addEventListener('click', () => {
            toggleEditMode();
        });
    }
}

/**
 * Toggle edit mode
 */
function toggleEditMode() {
    editMode = !editMode;
    const editBtn = document.getElementById('toggleEdit');
    if (editBtn) {
        editBtn.classList.toggle('active', editMode);
    }

    // Change cursor
    if (map) {
        map.getCanvas().style.cursor = editMode ? 'pointer' : 'grab';
    }

    console.log('Edit mode:', editMode ? 'ON' : 'OFF');
}

/**
 * Handle building click for edit mode
 */
function handleBuildingClickForEdit(e) {
    if (!editMode) return;
    if (e.features.length === 0) return;

    const feature = e.features[0];
    const props = feature.properties;

    // Extract building data
    const buildingData = {
        sd: props.sd || '',
        ed: props.ed || null,
        ev: props.ev || '',
        sd_src: props.sd_src || '',
        sd_method: props.sd_method || '',
        osm_id: props._src_id || props.osm_id || ''
    };

    showEditPopup(buildingData, e.lngLat, feature.geometry);
}

/**
 * Show edit popup for a building
 */
function showEditPopup(buildingData, coordinates, geometry) {
    // Close existing popup if any
    if (editPopup) {
        editPopup.remove();
    }

    const html = `
        <div class="edit-popup">
            <h3>Edit Building</h3>
            <div class="current-values">
                <div><strong>Built:</strong> ${buildingData.sd || 'N/A'}</div>
                <div><strong>Demolished:</strong> ${buildingData.ed || 'N/A'}</div>
                <div><strong>Evidence:</strong> ${buildingData.ev || 'N/A'}</div>
                <div><strong>Source:</strong> ${buildingData.sd_src || 'N/A'}</div>
                <div><strong>Method:</strong> ${buildingData.sd_method || 'N/A'}</div>
            </div>
            <div class="edit-form">
                <label>
                    Construction Year:
                    <input type="number" id="editSd" value="${buildingData.sd}" min="1700" max="2025" />
                </label>
                <label>
                    Demolition Year (optional):
                    <input type="number" id="editEd" value="${buildingData.ed || ''}" min="1700" max="2025" />
                </label>
                <div class="edit-actions">
                    <button id="saveEdit" class="save-btn">Save</button>
                    <button id="cancelEdit" class="cancel-btn">Cancel</button>
                </div>
            </div>
        </div>
    `;

    editPopup = new maplibregl.Popup({
        closeButton: false,
        closeOnClick: false,
        maxWidth: '320px'
    })
        .setLngLat(coordinates)
        .setHTML(html)
        .addTo(map);

    // Add event listeners after popup is added to DOM
    setTimeout(() => {
        const saveBtn = document.getElementById('saveEdit');
        const cancelBtn = document.getElementById('cancelEdit');

        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                const newSd = parseInt(document.getElementById('editSd').value);
                const edValue = document.getElementById('editEd').value;
                const newEd = edValue ? parseInt(edValue) : null;

                saveManualEdit(buildingData.osm_id, geometry, newSd, newEd);
            });
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                if (editPopup) {
                    editPopup.remove();
                    editPopup = null;
                }
            });
        }
    }, 100);
}

/**
 * Save manual edit to backend
 */
async function saveManualEdit(osmId, geometry, newSd, newEd) {
    try {
        const response = await fetch('http://localhost:5001/api/manual', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                osm_id: osmId,
                geometry: geometry,
                sd: newSd,
                ed: newEd
            })
        });

        if (!response.ok) {
            throw new Error(`Server responded with ${response.status}`);
        }

        const result = await response.json();
        console.log('Manual edit saved:', result);

        // Close popup
        if (editPopup) {
            editPopup.remove();
            editPopup = null;
        }

        // Add to overlay layer for immediate visibility
        addToManualEditsOverlay(result);

    } catch (error) {
        console.error('Failed to save manual edit:', error);
        alert('Failed to save: ' + error.message);
    }
}

/**
 * Update building layer paint based on debug mode
 * Debug mode shows date sources and inheritance methods
 */
function updateBuildingPaint() {
    if (!map || !map.getLayer('buildings')) return;

    if (debugColorMode) {
        // Debug colors by date source and inheritance method
        // Colors:
        //   Direct dates: finn=blue, sefrak=brown, manual=green, osm=gray
        //   Inherited: median=yellow, nearest=orange, fallback=red
        map.setPaintProperty('buildings', 'fill-color', [
            'case',
            // Fallback (red) - worst quality
            ['==', ['get', 'sd_method'], 'fallback'],
            '#e74c3c',
            // Nearest neighbor inherited (orange)
            ['==', ['get', 'sd_method'], 'nearest'],
            '#e67e22',
            // Median inherited (yellow)
            ['==', ['get', 'sd_method'], 'median'],
            '#f1c40f',
            // Direct from manual (green)
            ['==', ['get', 'sd_src'], 'manual'],
            '#2ecc71',
            // Direct from FINN (blue)
            ['==', ['get', 'sd_src'], 'finn'],
            '#3498db',
            // Direct from SEFRAK (brown)
            ['==', ['get', 'sd_src'], 'sefrak'],
            '#8b4513',
            // Direct from Trondheim Kommune (purple)
            ['==', ['get', 'sd_src'], 'tk'],
            '#9b59b6',
            // Direct from Matrikkelen (teal)
            ['==', ['get', 'sd_src'], 'mat'],
            '#1abc9c',
            // OSM or unknown (gray)
            '#95a5a6'
        ]);

        // Simpler outline in debug mode
        map.setPaintProperty('buildings-outline', 'line-color', '#2c3e50');
    } else {
        // Normal era-based coloring
        map.setPaintProperty('buildings', 'fill-color', [
            'case',
            // Manual (researcher verified) - green
            ['==', ['get', 'src'], 'man'],
            '#2ecc71',
            // SEFRAK buildings (historical colors by age)
            ['==', ['get', 'src'], 'sef'],
            [
                'interpolate',
                ['linear'],
                ['coalesce', ['get', 'sd'], 1850],
                1700, '#8b6914',
                1800, '#a67c2c',
                1850, '#b89968',
                1900, '#c9a876'
            ],
            // ML-verified buildings (brown)
            ['==', ['get', 'src'], 'ml'],
            '#8b4513',
            // Default (modern/unknown)
            '#d4a373'
        ]);

        // Normal outline coloring
        map.setPaintProperty('buildings-outline', 'line-color', [
            'case',
            ['==', ['get', 'src'], 'man'], '#1a8c4a',
            ['==', ['get', 'src'], 'ml'], '#5c2e0d',
            ['==', ['get', 'src'], 'sef'], '#5c4a1c',
            '#8b6f47'
        ]);
    }
}

/**
 * Toggle background layers visibility
 * Hides: roads layers, landuse layers, labels
 * Keeps: water visible
 */
function toggleBackgroundLayers(visible) {
    if (!map || !map.loaded()) return;
    const visibility = visible ? 'visible' : 'none';

    // Hide/show roads
    const roadLayers = ['roads', 'roads-background', 'roads-line', 'roads-outline',
                        'roads-historical', 'roads-historical-background', 'roads-historical-removed'];
    roadLayers.forEach(layerId => {
        if (map.getLayer(layerId)) {
            map.setLayoutProperty(layerId, 'visibility', visibility);
        }
    });

    // Hide/show landuse
    if (map.getLayer('landuse')) {
        map.setLayoutProperty('landuse', 'visibility', visibility);
    }

    // Hide/show labels
    if (map.getLayer('place-labels')) {
        map.setLayoutProperty('place-labels', 'visibility', visibility);
    }

    console.log('Background layers visibility:', visible ? 'visible' : 'hidden');
}

/**
 * Toggle buildings layer visibility
 */
function toggleBuildingsLayer(visible) {
    if (!map || !map.loaded()) return;
    const visibility = visible ? 'visible' : 'none';
    const buildingLayers = ['buildings', 'buildings-fill', 'buildings-outline', 'buildings-line'];
    buildingLayers.forEach(layerId => {
        if (map.getLayer(layerId)) {
            map.setLayoutProperty(layerId, 'visibility', visibility);
        }
    });
}

/**
 * Toggle roads layer visibility
 */
function toggleRoadsLayer(visible) {
    if (!map || !map.loaded()) return;
    const visibility = visible ? 'visible' : 'none';
    const roadLayers = ['roads', 'roads-line', 'roads-outline'];
    roadLayers.forEach(layerId => {
        if (map.getLayer(layerId)) {
            map.setLayoutProperty(layerId, 'visibility', visibility);
        }
    });
}

/**
 * Initialize collapsible section toggle handlers
 */
function initSectionToggles() {
    document.querySelectorAll('.filter-section-header').forEach(header => {
        header.addEventListener('click', () => {
            const section = header.closest('.filter-section');
            const icon = header.querySelector('.section-icon');

            section.classList.toggle('collapsed');

            // Update icon
            if (section.classList.contains('collapsed')) {
                icon.textContent = '▶';
            } else {
                icon.textContent = '▼';
            }
        });
    });
}

/**
 * Initialize base map layer controls (water, parks, labels)
 */
function initBaseMapControls() {
    document.querySelectorAll('[data-layer]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const layer = e.target.dataset.layer;
            baseMapLayers[layer] = e.target.checked;

            // Toggle corresponding map layers
            if (layer === 'water') {
                toggleLayer('water');
            } else if (layer === 'landuse') {
                // Toggle landuse layer
                const landuseVisible = e.target.checked ? 'visible' : 'none';
                if (map && map.getLayer('landuse')) {
                    map.setLayoutProperty('landuse', 'visibility', landuseVisible);
                }
            } else if (layer === 'labels') {
                // Toggle place labels
                const labelsVisible = e.target.checked ? 'visible' : 'none';
                if (map && map.getLayer('place-labels')) {
                    map.setLayoutProperty('place-labels', 'visibility', labelsVisible);
                }
            }
        });
    });
}

/**
 * Load and cache GeoJSON data for accurate source counting
 * Note: Disabled to improve initial load time when using PMTiles
 */
async function loadBuildingsData() {
    // Skip loading large GeoJSON - use queryRenderedFeatures instead
    console.log('Building counts will use rendered features (PMTiles mode)');
}

/**
 * Initialize source filter controls for dual-mode UI
 * Type A: Date Sources (timeline-aware)
 * Type B: Historical Snapshots (static)
 */
function initSourceFilterControls() {
    // === Building Filter Button (debug mode) ===
    const buildingFilterBtn = document.getElementById('buildingFilterBtn');
    const sourceFilterPanel = document.getElementById('sourceFilterPanel');

    if (buildingFilterBtn) {
        buildingFilterBtn.addEventListener('click', () => {
            sourceFilterEnabled = !sourceFilterEnabled;
            buildingFilterBtn.classList.toggle('active', sourceFilterEnabled);
            // Show/hide the source filter panel
            if (sourceFilterPanel) {
                sourceFilterPanel.style.display = sourceFilterEnabled ? 'block' : 'none';
            }
            // Update the map with new filter settings
            updateMapYear(currentYear);
            console.log('Building source filter:', sourceFilterEnabled ? 'ON (debug)' : 'OFF (production)');
        });
    }

    // === Road Filter Button ===
    const roadFilterBtn = document.getElementById('roadFilterBtn');
    const roadSourceFilterPanel = document.getElementById('roadSourceFilterPanel');
    let roadSourceFilterEnabled = false;

    if (roadFilterBtn) {
        roadFilterBtn.addEventListener('click', () => {
            roadSourceFilterEnabled = !roadSourceFilterEnabled;
            roadFilterBtn.classList.toggle('active', roadSourceFilterEnabled);
            // Show/hide the road source filter panel
            if (roadSourceFilterPanel) {
                roadSourceFilterPanel.style.display = roadSourceFilterEnabled ? 'block' : 'none';
            }
            console.log('Road source filter:', roadSourceFilterEnabled ? 'ON' : 'OFF');
        });
    }

    // === Date Sources Panel (Type A) ===
    const dateFilterToggle = document.getElementById('dateSourceFilterToggle');
    const dateFilterContainer = document.querySelector('.date-sources-filter');

    if (dateFilterToggle && dateFilterContainer) {
        dateFilterToggle.addEventListener('click', () => {
            dateFilterContainer.classList.toggle('collapsed');
        });
    }

    // Date Sources: Select All / Clear All buttons
    const selectAllDateBtn = document.getElementById('selectAllDateSources');
    const clearAllDateBtn = document.getElementById('clearAllDateSources');

    if (selectAllDateBtn) {
        selectAllDateBtn.addEventListener('click', () => {
            setAllDateSources(true);
        });
    }

    if (clearAllDateBtn) {
        clearAllDateBtn.addEventListener('click', () => {
            setAllDateSources(false);
        });
    }

    // Date Source checkboxes
    document.querySelectorAll('[data-date-source]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const source = e.target.dataset.dateSource;
            dateSourceFilter[source] = e.target.checked;
            updateMapYear(currentYear);
        });
    });

    // === Snapshot Sources Panel (Type B) ===
    const snapshotFilterToggle = document.getElementById('snapshotSourceFilterToggle');
    const snapshotFilterContainer = document.querySelector('.snapshot-sources-filter');

    if (snapshotFilterToggle && snapshotFilterContainer) {
        snapshotFilterToggle.addEventListener('click', () => {
            snapshotFilterContainer.classList.toggle('collapsed');
        });
    }

    // Snapshot Sources: Select All / Clear All buttons
    const selectAllSnapshotsBtn = document.getElementById('selectAllSnapshots');
    const clearAllSnapshotsBtn = document.getElementById('clearAllSnapshots');

    if (selectAllSnapshotsBtn) {
        selectAllSnapshotsBtn.addEventListener('click', () => {
            setAllSnapshots(true);
        });
    }

    if (clearAllSnapshotsBtn) {
        clearAllSnapshotsBtn.addEventListener('click', () => {
            setAllSnapshots(false);
        });
    }

    // Snapshot Source checkboxes
    document.querySelectorAll('[data-snapshot-source]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const source = e.target.dataset.snapshotSource;
            snapshotFilter[source] = e.target.checked;
            updateMapYear(currentYear);
        });
    });

    // Inspect button - enters inspection mode for first enabled snapshot
    const inspectBtn = document.getElementById('inspectSnapshotsBtn');
    if (inspectBtn) {
        inspectBtn.addEventListener('click', () => {
            // Find first enabled snapshot source
            const enabledSnapshot = Object.entries(snapshotFilter)
                .find(([_, enabled]) => enabled);

            if (enabledSnapshot) {
                enterInspectionMode(enabledSnapshot[0]);
            } else {
                // If no snapshot enabled, enable kv1880 and inspect it
                snapshotFilter.kv1880 = true;
                const checkbox = document.querySelector('[data-snapshot-source="kv1880"]');
                if (checkbox) checkbox.checked = true;
                updateMapYear(currentYear);
                enterInspectionMode('kv1880');
            }
        });
    }

    // Load buildings data for counting
    loadBuildingsData();
}

/**
 * Set all date sources enabled/disabled (Type A)
 */
function setAllDateSources(enabled) {
    Object.keys(dateSourceFilter).forEach(src => {
        dateSourceFilter[src] = enabled;
    });

    // Update checkboxes
    document.querySelectorAll('[data-date-source]').forEach(cb => {
        cb.checked = enabled;
    });

    updateMapYear(currentYear);
}

/**
 * Set all snapshot sources enabled/disabled (Type B)
 */
function setAllSnapshots(enabled) {
    Object.keys(snapshotFilter).forEach(src => {
        snapshotFilter[src] = enabled;
    });

    // Update checkboxes
    document.querySelectorAll('[data-snapshot-source]').forEach(cb => {
        cb.checked = enabled;
    });

    updateMapYear(currentYear);
}

/**
 * Initialize road source filter controls (simplified)
 */
function initRoadSourceControls() {
    // Road source checkboxes
    document.querySelectorAll('[data-road-source]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const source = e.target.dataset.roadSource;
            roadSourceFilter[source] = e.target.checked;
            updateMapYear(currentYear);
        });
    });

    console.log('Road source controls initialized');
}

/**
 * Set all road sources enabled/disabled
 */
function setAllRoadSources(enabled) {
    Object.keys(roadSourceFilter).forEach(src => {
        roadSourceFilter[src] = enabled;
    });

    // Update checkboxes
    document.querySelectorAll('[data-road-source]').forEach(cb => {
        cb.checked = enabled;
    });

    updateMapYear(currentYear);
}

/**
 * Set all sources enabled/disabled (legacy - calls both Type A and Type B)
 * @deprecated Use setAllDateSources() or setAllSnapshots() instead
 */
function setAllSources(enabled) {
    setAllDateSources(enabled);
    setAllSnapshots(enabled);
}

/**
 * Update source count badges
 * Uses cached GeoJSON data since querySourceFeatures doesn't work reliably with GeoJSON sources
 */
function updateSourceCounts() {
    if (!buildingsDataCache) {
        console.log('Buildings data not yet loaded for counting');
        return;
    }

    if (!map || !map.isStyleLoaded()) {
        return;
    }

    try {
        // Count by source from rendered features (visible in current view)
        const counts = { sef: 0, tk: 0, mat: 0, ml: 0, osm: 0 };

        const features = map.queryRenderedFeatures({ layers: ['buildings'] });
        features.forEach(f => {
            const src = f.properties.src;
            if (src && counts.hasOwnProperty(src)) {
                counts[src]++;
            }
        });

        // Update count badges (show ~ to indicate approximate/visible count)
        Object.entries(counts).forEach(([src, count]) => {
            const countEl = document.getElementById(`count-${src}`);
            if (countEl) {
                countEl.textContent = count > 0 ? `~${count.toLocaleString()}` : '-';
            }
        });
    } catch (e) {
        console.warn('Could not update source counts:', e);
    }
}

/**
 * Show loading indicator
 */
function showLoading() {
    const loading = document.getElementById('loading');
    if (loading) {
        loading.classList.remove('hidden');
        loading.style.display = 'block';
    }
}

/**
 * Hide loading indicator
 */
function hideLoading() {
    const loading = document.getElementById('loading');
    if (loading) {
        loading.classList.add('hidden');
        setTimeout(() => {
            loading.style.display = 'none';
        }, 300);
    }
}

/**
 * Show error message
 * @param {string} message - Error message to display
 */
function showError(message) {
    const errorEl = document.getElementById('error');
    const errorText = document.getElementById('errorText');

    if (errorEl && errorText) {
        errorText.textContent = message;
        errorEl.style.display = 'block';

        // Auto-hide after 5 seconds
        setTimeout(() => {
            errorEl.style.display = 'none';
        }, 5000);
    }

    console.error(message);
}

/**
 * Get color for change type
 * @param {string} changeType - Change type code
 * @returns {string} Color hex code
 */
function getChangeTypeColor(changeType) {
    const colors = {
        'same': '#888888',
        'widened': '#4a90d9',
        'rerouted': '#d97706',
        'replaced': '#7c3aed',
        'removed': '#dc2626',
        'new': '#16a34a'
    };
    return colors[changeType] || '#888888';
}

/**
 * Get human-readable label for evidence level
 * @param {string} evidence - Evidence code (h/m/l)
 * @returns {string} Human-readable label
 */
function getEvidenceLabel(evidence) {
    const labels = {
        'h': 'High confidence',
        'm': 'Medium confidence',
        'l': 'Low confidence'
    };
    return labels[evidence] || evidence;
}

/**
 * Parse URL parameters and apply initial state
 */
function applyUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);

    // Handle snapshot parameter: ?snapshot=kv1880
    const snapshotParam = urlParams.get('snapshot');
    if (snapshotParam && snapshotFilter.hasOwnProperty(snapshotParam)) {
        // Enable the specified snapshot
        snapshotFilter[snapshotParam] = true;
        // Update checkbox
        const checkbox = document.querySelector(`[data-snapshot-source="${snapshotParam}"]`);
        if (checkbox) {
            checkbox.checked = true;
        }
        console.log(`Enabled snapshot from URL: ${snapshotParam}`);
    }

    // Handle inspect parameter: ?inspect=kv1880 (enter inspection mode)
    const inspectParam = urlParams.get('inspect');
    if (inspectParam) {
        // Wait for map and sources to load, then enter inspection mode
        setTimeout(() => {
            if (historicalMapSources && historicalMapSources[inspectParam]) {
                enterInspectionMode(inspectParam);
            }
        }, 1000);
    }

    // Handle year parameter: ?year=1880
    const yearParam = urlParams.get('year');
    if (yearParam) {
        const year = parseInt(yearParam);
        if (year >= CONFIG.minYear && year <= CONFIG.maxYear) {
            currentYear = year;
            const slider = document.getElementById('yearSlider');
            if (slider) slider.value = year;
        }
    }
}

/**
 * Phase 4: Initialize manual edits overlay layer
 * Creates a GeoJSON source and layers for displaying manual edits
 */
function initManualEditsLayer() {
    if (!map) return;

    // Add empty GeoJSON source for manual edits
    map.addSource('manual-edits', {
        type: 'geojson',
        data: {
            type: 'FeatureCollection',
            features: []
        }
    });

    // Add fill layer with green color
    map.addLayer({
        id: 'manual-edits-fill',
        type: 'fill',
        source: 'manual-edits',
        paint: {
            'fill-color': '#2ecc71',
            'fill-opacity': 0.6
        }
    });

    // Add outline layer with dark green dashed pattern
    map.addLayer({
        id: 'manual-edits-outline',
        type: 'line',
        source: 'manual-edits',
        paint: {
            'line-color': '#1a8c4a',
            'line-width': 2,
            'line-dasharray': [2, 2]
        }
    });

    console.log('Manual edits overlay layer initialized');
}

/**
 * Phase 4: Load manual edits from API
 * Fetches manual edits data and updates the overlay
 */
async function loadManualEdits() {
    if (!map) return;

    try {
        const response = await fetch('http://localhost:5001/api/manual');
        if (!response.ok) {
            console.warn('Could not load manual edits:', response.status);
            return;
        }

        const data = await response.json();

        // Update the manual-edits source with the data
        const source = map.getSource('manual-edits');
        if (source) {
            source.setData(data);
            console.log('Loaded manual edits:', data.features ? data.features.length : 0, 'features');
        }
    } catch (error) {
        console.warn('Failed to load manual edits:', error);
    }
}

/**
 * Phase 4: Add a feature to the manual edits overlay
 * Called after successful save in saveManualEdit()
 * @param {object} feature - GeoJSON feature to add
 */
function addToManualEditsOverlay(feature) {
    if (!map) return;

    const source = map.getSource('manual-edits');
    if (!source) return;

    // Get current data
    const currentData = source._data || { type: 'FeatureCollection', features: [] };

    // Add new feature
    currentData.features.push(feature);

    // Update source
    source.setData(currentData);

    console.log('Added feature to manual edits overlay');
}

/**
 * Phase 5: Clear the manual edits overlay
 * Called after successful rebuild
 */
function clearManualEditsOverlay() {
    if (!map) return;

    const source = map.getSource('manual-edits');
    if (source) {
        source.setData({
            type: 'FeatureCollection',
            features: []
        });
        console.log('Cleared manual edits overlay');
    }
}

/**
 * Phase 5: Trigger rebuild of PMTiles
 * POSTs to rebuild API endpoint and reloads page on success
 */
async function triggerRebuild() {
    const statusEl = document.getElementById('rebuildStatus');

    // Show "Rebuilding..." status
    if (statusEl) {
        statusEl.textContent = 'Rebuilding...';
        statusEl.style.display = 'block';
    }

    try {
        const response = await fetch('http://localhost:5001/api/rebuild', {
            method: 'POST'
        });

        if (!response.ok) {
            throw new Error(`Rebuild failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('Rebuild result:', result);

        // Show success message
        if (statusEl) {
            statusEl.textContent = 'Complete!';
        }

        // Clear the manual edits overlay
        clearManualEditsOverlay();

        // Reload page after 2 seconds to get fresh PMTiles
        setTimeout(() => {
            window.location.reload();
        }, 2000);

    } catch (error) {
        console.error('Rebuild failed:', error);
        if (statusEl) {
            statusEl.textContent = 'Error: ' + error.message;
            statusEl.style.color = '#dc3545';
        }
    }
}

/**
 * Initialize the application
 */
function init() {
    console.log('Initializing Trondheim Historical Map application...');
    console.log('Configuration:', CONFIG);

    try {
        // Initialize PMTiles protocol
        initPMTiles();

        // Initialize controls
        initControls();

        // Apply URL parameters before initializing map
        applyUrlParams();

        // Initialize map
        initMap();

        // Load historical map sources manifest (async - buttons update when loaded)
        loadSourcesManifest();

    } catch (error) {
        console.error('Initialization failed:', error);
        showError('Failed to initialize application: ' + error.message);
        hideLoading();
    }
}

// Start the application when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    // DOM already loaded
    init();
}

// Export for debugging in console
window.HistoricalMap = {
    map,
    currentYear,
    updateMapYear,
    CONFIG
};
